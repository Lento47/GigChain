"""
W-CSAP Global Rate Limiter - HIGH SECURITY FIX
===============================================

Implements global rate limiting per wallet address to prevent distributed
brute-force attacks using IP rotation (botnets, VPNs, cloud proxies).

This fixes HIGH-004: No Global Rate Limiting Per Wallet

SECURITY FEATURES:
- Sliding window rate limiting (more accurate than fixed window)
- Global enforcement across all IPs
- Per-wallet and per-action granular limits
- Progressive penalties for repeated violations
- Distributed rate limiting via Redis
- Automatic cleanup of expired entries
- Comprehensive audit logging
"""

import time
import logging
from typing import Tuple, Optional, Dict, Any
from dataclasses import dataclass
from enum import Enum
import redis
from redis.exceptions import RedisError

logger = logging.getLogger(__name__)


class RateLimitAction(str, Enum):
    """Rate limit action types."""
    CHALLENGE_REQUEST = "challenge_request"
    VERIFY_ATTEMPT = "verify_attempt"
    REFRESH_REQUEST = "refresh_request"
    FAILED_AUTH = "failed_auth"
    LOGIN_SUCCESS = "login_success"


@dataclass
class RateLimitConfig:
    """Configuration for rate limiting."""
    # Per-hour limits
    challenge_per_hour: int = 50
    verify_per_hour: int = 50
    refresh_per_hour: int = 100
    failed_auth_per_hour: int = 10
    
    # Per-day limits
    challenge_per_day: int = 200
    verify_per_day: int = 200
    refresh_per_day: int = 500
    failed_auth_per_day: int = 30
    
    # Lockout settings
    max_failed_before_lockout: int = 5
    lockout_duration: int = 900  # 15 minutes
    progressive_lockout_multiplier: float = 2.0  # Double lockout time each violation


class GlobalRateLimiter:
    """
    Global rate limiter using Redis for distributed tracking.
    
    Implements sliding window algorithm for accurate rate limiting:
    - Each request is timestamped
    - Old requests outside the window are automatically removed
    - Counts requests within the sliding window
    """
    
    PREFIX_RATE_LIMIT = "wcsap:ratelimit:"
    PREFIX_LOCKOUT = "wcsap:lockout:"
    PREFIX_VIOLATION = "wcsap:violation:"
    
    def __init__(
        self,
        redis_url: str,
        config: Optional[RateLimitConfig] = None
    ):
        """
        Initialize global rate limiter.
        
        Args:
            redis_url: Redis connection URL
            config: Rate limit configuration
        """
        self.config = config or RateLimitConfig()
        
        try:
            self.redis = redis.from_url(
                redis_url,
                decode_responses=False,
                socket_timeout=2,
                socket_connect_timeout=2
            )
            self.redis.ping()
            logger.info(f\"\u2705 Global rate limiter connected to Redis\")\n        except RedisError as e:\n            logger.critical(f\"\u274c Failed to connect to Redis for rate limiting: {str(e)}\")\n            raise RuntimeError(f\"Rate limiter initialization failed: {str(e)}\")\n    \n    def check_rate_limit(\n        self,\n        wallet_address: str,\n        action: RateLimitAction,\n        ip_address: Optional[str] = None\n    ) -> Tuple[bool, int, str]:\n        \"\"\"\n        Check if rate limit is exceeded for a wallet.\n        \n        Args:\n            wallet_address: Wallet address to check\n            action: Action type being performed\n            ip_address: Optional IP address for additional tracking\n            \n        Returns:\n            Tuple of (is_allowed, attempts_remaining, reason)\n        \"\"\"\n        try:\n            # Normalize wallet address\n            wallet_address = wallet_address.lower()\n            \n            # Check if wallet is locked out\n            if self._is_locked_out(wallet_address):\n                lockout_remaining = self._get_lockout_remaining(wallet_address)\n                logger.warning(\n                    f\"\ud83d\udeab Rate limit: Wallet locked out: {wallet_address[:10]}...\",\n                    extra={\n                        \"wallet_address\": wallet_address,\n                        \"lockout_remaining\": lockout_remaining\n                    }\n                )\n                return False, 0, f\"Account locked due to repeated violations. Try again in {lockout_remaining}s\"\n            \n            # Get limits for this action\n            hourly_limit, daily_limit = self._get_limits_for_action(action)\n            \n            # Check hourly limit\n            hourly_key = f\"{self.PREFIX_RATE_LIMIT}{wallet_address}:{action.value}:hour\"\n            hourly_count = self._count_requests_in_window(hourly_key, 3600)\n            \n            if hourly_count >= hourly_limit:\n                logger.warning(\n                    f\"\ud83d\udeab Rate limit: Hourly limit exceeded: {wallet_address[:10]}... \"\n                    f\"({hourly_count}/{hourly_limit})\",\n                    extra={\n                        \"wallet_address\": wallet_address,\n                        \"action\": action.value,\n                        \"count\": hourly_count,\n                        \"limit\": hourly_limit\n                    }\n                )\n                # Record violation\n                self._record_violation(wallet_address, \"hourly_limit_exceeded\")\n                return False, 0, f\"Hourly rate limit exceeded ({hourly_limit} requests/hour)\"\n            \n            # Check daily limit\n            daily_key = f\"{self.PREFIX_RATE_LIMIT}{wallet_address}:{action.value}:day\"\n            daily_count = self._count_requests_in_window(daily_key, 86400)\n            \n            if daily_count >= daily_limit:\n                logger.warning(\n                    f\"\ud83d\udeab Rate limit: Daily limit exceeded: {wallet_address[:10]}... \"\n                    f\"({daily_count}/{daily_limit})\",\n                    extra={\n                        \"wallet_address\": wallet_address,\n                        \"action\": action.value,\n                        \"count\": daily_count,\n                        \"limit\": daily_limit\n                    }\n                )\n                # Record violation (more severe)\n                self._record_violation(wallet_address, \"daily_limit_exceeded\")\n                return False, 0, f\"Daily rate limit exceeded ({daily_limit} requests/day)\"\n            \n            # All checks passed - allow request\n            attempts_remaining = min(\n                hourly_limit - hourly_count - 1,\n                daily_limit - daily_count - 1\n            )\n            \n            logger.debug(\n                f\"\u2705 Rate limit OK: {wallet_address[:10]}... \"\n                f\"({hourly_count + 1}/{hourly_limit} hourly, {daily_count + 1}/{daily_limit} daily)\"\n            )\n            \n            return True, attempts_remaining, \"OK\"\n            \n        except Exception as e:\n            logger.error(f\"Rate limit check error: {str(e)}\")\n            # FAIL OPEN for rate limiting (don't block users if Redis is down)\n            # But log the error for monitoring\n            return True, 999, \"Rate limit check unavailable\"\n    \n    def record_request(\n        self,\n        wallet_address: str,\n        action: RateLimitAction,\n        ip_address: Optional[str] = None,\n        success: bool = True\n    ) -> bool:\n        \"\"\"\n        Record a request for rate limiting.\n        \n        Args:\n            wallet_address: Wallet address\n            action: Action type\n            ip_address: Optional IP address\n            success: Whether the request was successful\n            \n        Returns:\n            True if recorded successfully\n        \"\"\"\n        try:\n            wallet_address = wallet_address.lower()\n            current_time = time.time()\n            \n            # Record in hourly window\n            hourly_key = f\"{self.PREFIX_RATE_LIMIT}{wallet_address}:{action.value}:hour\"\n            self.redis.zadd(hourly_key, {str(current_time): current_time})\n            self.redis.expire(hourly_key, 3600)\n            \n            # Record in daily window\n            daily_key = f\"{self.PREFIX_RATE_LIMIT}{wallet_address}:{action.value}:day\"\n            self.redis.zadd(daily_key, {str(current_time): current_time})\n            self.redis.expire(daily_key, 86400)\n            \n            # If failed auth, check if we need to lock out\n            if action == RateLimitAction.FAILED_AUTH and not success:\n                self._check_and_apply_lockout(wallet_address)\n            \n            return True\n            \n        except Exception as e:\n            logger.error(f\"Failed to record request: {str(e)}\")\n            return False\n    \n    def _count_requests_in_window(self, key: str, window_seconds: int) -> int:\n        \"\"\"\n        Count requests in sliding time window.\n        \n        Args:\n            key: Redis key\n            window_seconds: Window size in seconds\n            \n        Returns:\n            Number of requests in window\n        \"\"\"\n        try:\n            current_time = time.time()\n            window_start = current_time - window_seconds\n            \n            # Remove old entries outside the window\n            self.redis.zremrangebyscore(key, 0, window_start)\n            \n            # Count remaining entries\n            count = self.redis.zcard(key)\n            \n            return count\n            \n        except Exception as e:\n            logger.error(f\"Failed to count requests: {str(e)}\")\n            return 0\n    \n    def _get_limits_for_action(self, action: RateLimitAction) -> Tuple[int, int]:\n        \"\"\"\n        Get hourly and daily limits for an action.\n        \n        Args:\n            action: Action type\n            \n        Returns:\n            Tuple of (hourly_limit, daily_limit)\n        \"\"\"\n        if action == RateLimitAction.CHALLENGE_REQUEST:\n            return self.config.challenge_per_hour, self.config.challenge_per_day\n        elif action == RateLimitAction.VERIFY_ATTEMPT:\n            return self.config.verify_per_hour, self.config.verify_per_day\n        elif action == RateLimitAction.REFRESH_REQUEST:\n            return self.config.refresh_per_hour, self.config.refresh_per_day\n        elif action == RateLimitAction.FAILED_AUTH:\n            return self.config.failed_auth_per_hour, self.config.failed_auth_per_day\n        else:\n            return 100, 1000  # Default limits\n    \n    def _is_locked_out(self, wallet_address: str) -> bool:\n        \"\"\"\n        Check if wallet is currently locked out.\n        \n        Args:\n            wallet_address: Wallet address\n            \n        Returns:\n            True if locked out\n        \"\"\"\n        try:\n            lockout_key = f\"{self.PREFIX_LOCKOUT}{wallet_address}\"\n            return bool(self.redis.exists(lockout_key))\n        except Exception as e:\n            logger.error(f\"Failed to check lockout: {str(e)}\")\n            return False\n    \n    def _get_lockout_remaining(self, wallet_address: str) -> int:\n        \"\"\"\n        Get remaining lockout time in seconds.\n        \n        Args:\n            wallet_address: Wallet address\n            \n        Returns:\n            Seconds remaining in lockout\n        \"\"\"\n        try:\n            lockout_key = f\"{self.PREFIX_LOCKOUT}{wallet_address}\"\n            ttl = self.redis.ttl(lockout_key)\n            return max(0, ttl)\n        except Exception as e:\n            logger.error(f\"Failed to get lockout remaining: {str(e)}\")\n            return 0\n    \n    def _check_and_apply_lockout(self, wallet_address: str):\n        \"\"\"\n        Check failed auth attempts and apply lockout if threshold exceeded.\n        \n        Args:\n            wallet_address: Wallet address\n        \"\"\"\n        try:\n            # Count recent failed auth attempts (last hour)\n            failed_key = f\"{self.PREFIX_RATE_LIMIT}{wallet_address}:{RateLimitAction.FAILED_AUTH.value}:hour\"\n            failed_count = self._count_requests_in_window(failed_key, 3600)\n            \n            if failed_count >= self.config.max_failed_before_lockout:\n                # Get violation count for progressive lockout\n                violation_count = self._get_violation_count(wallet_address)\n                \n                # Calculate lockout duration (progressive)\n                lockout_duration = int(\n                    self.config.lockout_duration *\n                    (self.config.progressive_lockout_multiplier ** violation_count)\n                )\n                \n                # Cap maximum lockout at 24 hours\n                lockout_duration = min(lockout_duration, 86400)\n                \n                # Apply lockout\n                lockout_key = f\"{self.PREFIX_LOCKOUT}{wallet_address}\"\n                self.redis.setex(lockout_key, lockout_duration, \"1\")\n                \n                logger.critical(\n                    f\"\ud83d\udea8 SECURITY: Wallet locked out due to {failed_count} failed auth attempts: \"\n                    f\"{wallet_address[:10]}... (duration: {lockout_duration}s)\",\n                    extra={\n                        \"wallet_address\": wallet_address,\n                        \"failed_count\": failed_count,\n                        \"lockout_duration\": lockout_duration,\n                        \"violation_count\": violation_count\n                    }\n                )\n                \n                # Record violation\n                self._record_violation(wallet_address, \"lockout_applied\")\n                \n        except Exception as e:\n            logger.error(f\"Failed to check/apply lockout: {str(e)}\")\n    \n    def _record_violation(self, wallet_address: str, violation_type: str):\n        \"\"\"\n        Record a rate limit violation.\n        \n        Args:\n            wallet_address: Wallet address\n            violation_type: Type of violation\n        \"\"\"\n        try:\n            violation_key = f\"{self.PREFIX_VIOLATION}{wallet_address}\"\n            current_time = time.time()\n            \n            # Add violation to sorted set (timestamp as score)\n            self.redis.zadd(violation_key, {f\"{violation_type}:{current_time}\": current_time})\n            \n            # Keep violations for 7 days\n            self.redis.expire(violation_key, 604800)\n            \n            # Clean up old violations (older than 7 days)\n            week_ago = current_time - 604800\n            self.redis.zremrangebyscore(violation_key, 0, week_ago)\n            \n        except Exception as e:\n            logger.error(f\"Failed to record violation: {str(e)}\")\n    \n    def _get_violation_count(self, wallet_address: str) -> int:\n        \"\"\"\n        Get violation count for a wallet (last 7 days).\n        \n        Args:\n            wallet_address: Wallet address\n            \n        Returns:\n            Violation count\n        \"\"\"\n        try:\n            violation_key = f\"{self.PREFIX_VIOLATION}{wallet_address}\"\n            return self.redis.zcard(violation_key)\n        except Exception as e:\n            logger.error(f\"Failed to get violation count: {str(e)}\")\n            return 0\n    \n    def reset_wallet_limits(self, wallet_address: str) -> bool:\n        \"\"\"\n        Reset rate limits and lockout for a wallet (admin function).\n        \n        Args:\n            wallet_address: Wallet address\n            \n        Returns:\n            True if successful\n        \"\"\"\n        try:\n            wallet_address = wallet_address.lower()\n            \n            # Delete all rate limit keys\n            pattern = f\"{self.PREFIX_RATE_LIMIT}{wallet_address}:*\"\n            for key in self.redis.scan_iter(match=pattern):\n                self.redis.delete(key)\n            \n            # Delete lockout\n            lockout_key = f\"{self.PREFIX_LOCKOUT}{wallet_address}\"\n            self.redis.delete(lockout_key)\n            \n            logger.info(f\"Rate limits reset for wallet: {wallet_address[:10]}...\")\n            return True\n            \n        except Exception as e:\n            logger.error(f\"Failed to reset wallet limits: {str(e)}\")\n            return False\n    \n    def get_wallet_status(self, wallet_address: str) -> Dict[str, Any]:\n        \"\"\"\n        Get rate limit status for a wallet.\n        \n        Args:\n            wallet_address: Wallet address\n            \n        Returns:\n            Dictionary with rate limit status\n        \"\"\"\n        try:\n            wallet_address = wallet_address.lower()\n            \n            status = {\n                \"wallet_address\": wallet_address,\n                \"is_locked_out\": self._is_locked_out(wallet_address),\n                \"lockout_remaining\": self._get_lockout_remaining(wallet_address),\n                \"violation_count\": self._get_violation_count(wallet_address),\n                \"current_counts\": {}\n            }\n            \n            # Get counts for each action\n            for action in RateLimitAction:\n                hourly_key = f\"{self.PREFIX_RATE_LIMIT}{wallet_address}:{action.value}:hour\"\n                daily_key = f\"{self.PREFIX_RATE_LIMIT}{wallet_address}:{action.value}:day\"\n                \n                hourly_count = self._count_requests_in_window(hourly_key, 3600)\n                daily_count = self._count_requests_in_window(daily_key, 86400)\n                \n                hourly_limit, daily_limit = self._get_limits_for_action(action)\n                \n                status[\"current_counts\"][action.value] = {\n                    \"hourly\": {\"count\": hourly_count, \"limit\": hourly_limit},\n                    \"daily\": {\"count\": daily_count, \"limit\": daily_limit}\n                }\n            \n            return status\n            \n        except Exception as e:\n            logger.error(f\"Failed to get wallet status: {str(e)}\")\n            return {\"error\": str(e)}\n\n\n# Singleton instance\n_rate_limiter_instance: Optional[GlobalRateLimiter] = None\n\n\ndef get_rate_limiter(\n    redis_url: str = \"redis://localhost:6379/0\",\n    config: Optional[RateLimitConfig] = None\n) -> GlobalRateLimiter:\n    \"\"\"\n    Get or create global rate limiter singleton.\n    \n    Args:\n        redis_url: Redis connection URL\n        config: Rate limit configuration\n        \n    Returns:\n        GlobalRateLimiter instance\n    \"\"\"\n    global _rate_limiter_instance\n    \n    if _rate_limiter_instance is None:\n        _rate_limiter_instance = GlobalRateLimiter(redis_url, config)\n    \n    return _rate_limiter_instance\n\n\ndef reset_rate_limiter():\n    \"\"\"Reset rate limiter singleton (useful for testing).\"\"\"\n    global _rate_limiter_instance\n    _rate_limiter_instance = None\n\n\n__all__ = [\n    'GlobalRateLimiter',\n    'RateLimitAction',\n    'RateLimitConfig',\n    'get_rate_limiter',\n    'reset_rate_limiter'\n]\n